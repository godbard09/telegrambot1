from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import Application, CallbackQueryHandler, CommandHandler, ContextTypes
import ccxt
import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import os
import asyncio
import json
import pytz
import re
import os
import plotly.figure_factory as ff
import numpy as np
import requests
import traceback
from datetime import datetime, timezone
import time

# Token bot t·ª´ BotFather
TOKEN = "8117660223:AAHCEFYmz7GxYd9O7H-wIsp2P-J_o-kxP7s"

# ƒê·ªãa ch·ªâ Webhook (thay YOUR_RENDER_URL b·∫±ng URL ·ª©ng d·ª•ng Render c·ªßa b·∫°n)
WEBHOOK_URL = f"https://telegrambot1-08ni.onrender.com"
# Kh·ªüi t·∫°o KuCoin
exchange = ccxt.kucoin()
# L∆∞u tr·ªØ l·ªãch s·ª≠ t√≠n hi·ªáu
signal_history = {}

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """G·ª≠i tin nh·∫Øn ch√†o m·ª´ng v√† h∆∞·ªõng d·∫´n."""
    await update.message.reply_text(
        "Ch√†o m·ª´ng! T√¥i l√† bot h·ªó tr·ª£ c·∫£nh b√°o t√≠n hi·ªáu mua/b√°n ti·ªÅn m√£ h√≥a.\n"
        "D∆∞·ªõi ƒë√¢y l√† c√°c l·ªánh b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng:\n"
        "G√µ /chart <m√£ giao d·ªãch> ƒë·ªÉ xem bi·ªÉu ƒë·ªì k·ªπ thu·∫≠t (v√≠ d·ª•: /chart BTC/USDT).\n"
        "G√µ /top ƒë·ªÉ xem top 10 c·∫∑p giao d·ªãch tƒÉng, gi·∫£m m·∫°nh nh·∫•t 24 gi·ªù qua.\n"
        "G√µ /signal <m√£ giao d·ªãch> ƒë·ªÉ xem l·ªãch s·ª≠ t√≠n hi·ªáu mua b√°n trong 7 ng√†y qua.\n"
        "G√µ /smarttrade <m√£ giao d·ªãch> ƒë·ªÉ xem th√¥ng tin v√† t√≠n hi·ªáu mua b√°n m·ªõi nh·∫•t.\n"
        "G√µ /list ƒë·ªÉ xem top 10 c·∫∑p giao d·ªãch c√≥ t√≠n hi·ªáu mua b√°n g·∫ßn ƒë√¢y.\n"
        "G√µ /info ƒë·ªÉ xem th√¥ng tin ƒë·ªìng coin.\n"
        "G√µ /heatmap ƒë·ªÉ xem heatmap c·ªßa 100 ƒë·ªìng coin.\n"
        "G√µ /sentiment ƒë·ªÉ xem sentiment.\n"
        "G√µ /desc ƒë·ªÉ xem m√¥ t·∫£ ƒë·ªìng coin.\n"
        "G√µ /trending ƒë·ªÉ xem top 15 trend coin."
    )


# Kh·ªüi t·∫°o m√∫i gi·ªù Vi·ªát Nam
vietnam_tz = pytz.timezone('Asia/Ho_Chi_Minh')


def escape_markdown(text: str, ignore: list = None) -> str:
    """
    Tho√°t c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát cho Markdown v2.
    C√°c k√Ω t·ª± trong danh s√°ch `ignore` s·∫Ω kh√¥ng b·ªã tho√°t.
    """
    if ignore is None:
        ignore = []
    # C√°c k√Ω t·ª± Markdown c·∫ßn tho√°t
    escape_chars = r"_*[]()~`>#+-=|{}.!"
    # Lo·∫°i b·ªè c√°c k√Ω t·ª± trong danh s√°ch ignore
    for char in ignore:
        escape_chars = escape_chars.replace(char, "")
    # Thay th·∫ø c√°c k√Ω t·ª± c·∫ßn tho√°t b·∫±ng c√°ch th√™m d·∫•u '\'
    return re.sub(f"([{re.escape(escape_chars)}])", r"\\\1", text)


async def current_price(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    try:
        symbol = context.args[0] if context.args else None
        if not symbol:
            await update.message.reply_text("Vui l√≤ng cung c·∫•p m√£ giao d·ªãch. V√≠ d·ª•: /smarttrade BTC/USDT")
            return

        markets = exchange.load_markets()
        if symbol not in markets:
            await update.message.reply_text(f"M√£ giao d·ªãch kh√¥ng h·ª£p l·ªá: {symbol}. Vui l√≤ng ki·ªÉm tra l·∫°i.")
            return

        quote_currency = symbol.split('/')[1]
        ticker = exchange.fetch_ticker(symbol)
        current_price = ticker['last']
        percentage_change = ticker['percentage']
        volume_24h = ticker.get('quoteVolume', 0)

        timestamp = (
            pd.to_datetime(ticker['timestamp'], unit='ms')
            .tz_localize('UTC')
            .tz_convert(vietnam_tz)
            .strftime('%Y-%m-%d %H:%M:%S')
        )

        timeframe = '2h'
        limit = 500
        ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        df['timestamp'] = (
            pd.to_datetime(df['timestamp'], unit='ms')
            .dt.tz_localize('UTC')
            .dt.tz_convert(vietnam_tz)
        )

        if len(df) < 100:
            await update.message.reply_text("Kh√¥ng ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ t√≠nh to√°n ch·ªâ b√°o k·ªπ thu·∫≠t. Vui l√≤ng th·ª≠ l·∫°i sau.")
            return

        df['MA50'] = df['close'].rolling(window=50).mean()
        df['MA100'] = df['close'].rolling(window=100).mean()
        df['EMA12'] = df['close'].ewm(span=12).mean()
        df['EMA26'] = df['close'].ewm(span=26).mean()
        df['MACD'] = df['EMA12'] - df['EMA26']
        df['Signal'] = df['MACD'].ewm(span=9).mean()
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / loss
        df['RSI'] = 100 - (100 / (1 + rs))
        df['BB_Middle'] = df['close'].rolling(window=20).mean()
        df['BB_Upper'] = df['BB_Middle'] + 2 * df['close'].rolling(window=20).std()
        df['BB_Lower'] = df['BB_Middle'] - 2 * df['close'].rolling(window=20).std()

        trend = "Kh√¥ng x√°c ƒë·ªãnh"
        if len(df) > 1:
            last_row = df.iloc[-1]
            prev_row = df.iloc[-2]
            if last_row['close'] > last_row['MA50'] and last_row['close'] > last_row['MA100'] and last_row['MA50'] > prev_row['MA50']:
                trend = "TƒÇNG"
            elif last_row['close'] < last_row['MA50'] and last_row['close'] < last_row['MA100'] and last_row['MA50'] < prev_row['MA50']:
                trend = "GI·∫¢M"
            else:
                trend = "ƒêI NGANG"

        signals = []
        for _, row in df.iterrows():
            if row['close'] > row['MA50'] and row['MACD'] > row['Signal'] and row['RSI'] < 30:
                signals.append({"type": "MUA", "price": row['close'], "timestamp": row['timestamp']})
            elif row['close'] <= row['BB_Lower']:
                signals.append({"type": "MUA", "price": row['close'], "timestamp": row['timestamp']})
            elif row['close'] < row['MA50'] and row['MACD'] < row['Signal'] and row['RSI'] > 70:
                signals.append({"type": "B√ÅN", "price": row['close'], "timestamp": row['timestamp']})
            elif row['close'] >= row['BB_Upper']:
                signals.append({"type": "B√ÅN", "price": row['close'], "timestamp": row['timestamp']})

        recent_signal = signals[-1] if signals else None
        position_info = "Kh√¥ng c√≥ t√≠n hi·ªáu mua/b√°n g·∫ßn ƒë√¢y."

        if recent_signal:
            signal_age = (pd.Timestamp.utcnow().tz_convert(vietnam_tz) - recent_signal['timestamp']).total_seconds() / 3600
            position_status = "THEO D√ïI" if signal_age > 2 else recent_signal['type']
            if recent_signal['type'] == "MUA":
                profit_loss = ((current_price - recent_signal['price']) / recent_signal['price']) * 100
                profit_color = (
                    f"{profit_loss:.2f}% üü¢" if profit_loss > 0 else
                    f"{profit_loss:.2f}% üî¥" if profit_loss < 0 else
                    f"{profit_loss:.2f}% üü°"
                )
                position_info = (
                    f"- Xu h∆∞·ªõng: **{trend}**\n"
                    f"- V·ªã th·∫ø hi·ªán t·∫°i: **{position_status}**\n"
                    f"- Ng√†y mua: {recent_signal['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}\n"
                    f"- Gi√° mua: {recent_signal['price']:.2f} {quote_currency}\n"
                    f"- L√£i/L·ªó: {profit_color}"
                )
            elif recent_signal['type'] == "B√ÅN":
                buy_signals = [s for s in signals if s['type'] == "MUA" and s['timestamp'] < recent_signal['timestamp']]
                if buy_signals:
                    prior_buy = max(buy_signals, key=lambda x: x['timestamp'])  # Ch·ªçn l·∫ßn mua g·∫ßn nh·∫•t
                    profit_loss = ((recent_signal['price'] - prior_buy['price']) / prior_buy['price']) * 100
                    profit_color = (
                        f"{profit_loss:.2f}% üü¢" if profit_loss > 0 else
                        f"{profit_loss:.2f}% üî¥" if profit_loss < 0 else
                        f"{profit_loss:.2f}% üü°"
                    )
                    position_info = (
                        f"- Xu h∆∞·ªõng: **{trend}**\n"
                        f"- V·ªã th·∫ø hi·ªán t·∫°i: **{position_status}**\n"
                        f"- Ng√†y mua: {prior_buy['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}\n"
                        f"- Gi√° mua: {prior_buy['price']:.2f} {quote_currency}\n"
                        f"- Ng√†y b√°n: {recent_signal['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}\n"
                        f"- Gi√° b√°n: {recent_signal['price']:.2f} {quote_currency}\n"
                        f"- L√£i/L·ªó: {profit_color}"
                    )
                else:
                    position_info = (
                        f"- Xu h∆∞·ªõng: **{trend}**\n"
                        f"- V·ªã th·∫ø hi·ªán t·∫°i: **{position_status}**\n"
                        f"- Ng√†y b√°n: {recent_signal['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}\n"
                        f"- Gi√° b√°n: {recent_signal['price']:.2f} {quote_currency}\n"
                        f"- L√£i/L·ªó: Kh√¥ng x√°c ƒë·ªãnh (kh√¥ng c√≥ t√≠n hi·ªáu mua tr∆∞·ªõc ƒë√≥)."
                    )


        message = escape_markdown(
            f"Th√¥ng tin gi√° hi·ªán t·∫°i cho {symbol}:\n"
            f"- Gi√° hi·ªán t·∫°i: {current_price:.2f} {quote_currency}\n"
            f"- Bi·∫øn ƒë·ªông trong 24 gi·ªù qua: {percentage_change:.2f}%\n"
            f"- Kh·ªëi l∆∞·ª£ng giao d·ªãch trong 24 gi·ªù qua: {volume_24h:.2f} {quote_currency}\n"
            f"- Th·ªùi gian c·∫≠p nh·∫≠t: {timestamp}\n\n"
            f"Th√¥ng tin v·ªã th·∫ø:\n{position_info}",
            ignore=["*"]
        )
        await update.message.reply_text(message, parse_mode="MarkdownV2")

    except Exception as e:
        await update.message.reply_text(f"ƒê√£ x·∫£y ra l·ªói: {e}")

async def chart(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """T·∫°o v√† g·ª≠i bi·ªÉu ƒë·ªì k·ªπ thu·∫≠t."""
    try:
        symbol = context.args[0] if context.args else context.chat_data.get("symbol")
        if not symbol:
            await update.message.reply_text("Vui l√≤ng cung c·∫•p m√£ giao d·ªãch. V√≠ d·ª•: /chart BTC/USDT")
            return

        timeframe = '1h'
        limit = 8760

        markets = exchange.load_markets()
        if symbol not in markets:
            await update.message.reply_text(f"M√£ giao d·ªãch kh√¥ng h·ª£p l·ªá: {symbol}. Vui l√≤ng ki·ªÉm tra l·∫°i.")
            return

        ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
        # Chuy·ªÉn ƒë·ªïi timestamp sang gi·ªù Vi·ªát Nam
        df['timestamp'] = (
            pd.to_datetime(df['timestamp'], unit='ms')
            .dt.tz_localize('UTC')
            .dt.tz_convert(vietnam_tz)
        )

        # T√≠nh to√°n c√°c ch·ªâ b√°o k·ªπ thu·∫≠t
        df['MA50'] = df['close'].rolling(window=50).mean()
        df['MA100'] = df['close'].rolling(window=100).mean()

        # Bollinger Bands
        df['BB_Middle'] = df['close'].rolling(window=20).mean()
        df['BB_Upper'] = df['BB_Middle'] + 2 * df['close'].rolling(window=20).std()
        df['BB_Lower'] = df['BB_Middle'] - 2 * df['close'].rolling(window=20).std()

        # MACD
        df['EMA12'] = df['close'].ewm(span=12).mean()
        df['EMA26'] = df['close'].ewm(span=26).mean()
        df['MACD'] = df['EMA12'] - df['EMA26']
        df['Signal'] = df['MACD'].ewm(span=9).mean()
        df['MACD_Hist'] = df['MACD'] - df['Signal']

        # RSI
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / loss
        df['RSI'] = 100 - (100 / (1 + rs))

        # Bi·ªÉu ƒë·ªì Candlestick v√† MACD ƒë∆∞·ª£c ƒë·∫∑t ri√™ng bi·ªát
        fig = make_subplots(
            rows=4,  # TƒÉng s·ªë l∆∞·ª£ng h√†ng l√™n 4 ƒë·ªÉ t√°ch MACD kh·ªèi bi·ªÉu ƒë·ªì gi√°
            cols=1,
            shared_xaxes=True,
            vertical_spacing=0.03,
            row_heights=[0.5, 0.2, 0.2, 0.1],  # C·∫≠p nh·∫≠t chi·ªÅu cao t·ª´ng h√†ng
            specs=[[{"secondary_y": True}], [{}], [{}], [{}]]
        )

        # Candlestick v√† Bollinger Bands
        fig.add_trace(go.Candlestick(
            x=df['timestamp'],
            open=df['open'],
            high=df['high'],
            low=df['low'],
            close=df['close'],
            name="Candlestick"
        ), row=1, col=1, secondary_y=False)

        fig.add_trace(go.Scatter(
            x=df['timestamp'],
            y=df['BB_Upper'],
            mode='lines',
            line=dict(color='red', width=1),
            name='BB Upper'
        ), row=1, col=1, secondary_y=False)

        fig.add_trace(go.Scatter(
            x=df['timestamp'],
            y=df['BB_Middle'],
            mode='lines',
            line=dict(color='blue', width=1),
            name='BB Middle'
        ), row=1, col=1, secondary_y=False)

        fig.add_trace(go.Scatter(
            x=df['timestamp'],
            y=df['BB_Lower'],
            mode='lines',
            line=dict(color='green', width=1),
            name='BB Lower'
        ), row=1, col=1, secondary_y=False)

        # Th√™m c√°c ƒë∆∞·ªùng MA50 v√† MA100
        fig.add_trace(go.Scatter(
            x=df['timestamp'],
            y=df['MA50'],
            mode='lines',
            line=dict(color='orange', width=1.5),
            name='MA50'
        ), row=1, col=1, secondary_y=False)

        fig.add_trace(go.Scatter(
            x=df['timestamp'],
            y=df['MA100'],
            mode='lines',
            line=dict(color='purple', width=1.5),
            name='MA100'
        ), row=1, col=1, secondary_y=False)

        # Bi·ªÉu ƒë·ªì kh·ªëi l∆∞·ª£ng b√™n tr·ª•c y2, c√πng m√†u v·ªõi gi√°
        volume_colors = [
            'green' if row['close'] > row['open'] else 'red'
            for _, row in df.iterrows()
        ]
        fig.add_trace(go.Bar(
            x=df['timestamp'],
            y=df['volume'],
            name='Volume',
            marker_color=volume_colors
        ), row=1, col=1, secondary_y=True)

        # Bi·ªÉu ƒë·ªì MACD (ƒë∆∞·ª£c chuy·ªÉn sang h√†ng 2)
        fig.add_trace(go.Bar(
            x=df['timestamp'],
            y=df['MACD_Hist'],
            name='MACD Histogram'
        ), row=2, col=1)

        fig.add_trace(go.Scatter(
            x=df['timestamp'],
            y=df['MACD'],
            mode='lines',
            line=dict(color='green', width=1),
            name='MACD'
        ), row=2, col=1)

        fig.add_trace(go.Scatter(
            x=df['timestamp'],
            y=df['Signal'],
            mode='lines',
            line=dict(color='red', width=1),
            name='Signal'
        ), row=2, col=1)

        # Bi·ªÉu ƒë·ªì RSI (h√†ng 3)
        fig.add_trace(go.Scatter(
            x=df['timestamp'],
            y=df['RSI'],
            mode='lines',
            line=dict(color='purple', width=1),
            name='RSI'
        ), row=3, col=1)

        # ƒê∆∞·ªùng gi·ªõi h·∫°n RSI
        fig.add_trace(go.Scatter(
            x=df['timestamp'],
            y=[70] * len(df),
            mode='lines',
            line=dict(color='red', dash='dash'),
            name='Overbought (70)'
        ), row=3, col=1)

        fig.add_trace(go.Scatter(
            x=df['timestamp'],
            y=[30] * len(df),
            mode='lines',
            line=dict(color='blue', dash='dash'),
            name='Oversold (30)'
        ), row=3, col=1)

        # Layout
        fig.update_layout(
            title=f"BI·ªÇU ƒê·ªí PH√ÇN T√çCH K·ª∏ THU·∫¨T (1H) C·ª¶A {symbol}",
            template="plotly_dark",
            height=1200,  # TƒÉng chi·ªÅu cao bi·ªÉu ƒë·ªì t·ªïng th·ªÉ
            xaxis_rangeslider_visible=False
        )

        # L∆∞u bi·ªÉu ƒë·ªì th√†nh HTML
        temp_file = f"{symbol.replace('/', '_')}_chart.html"
        fig.write_html(temp_file)

        # G·ª≠i file HTML qua Telegram
        if update.callback_query:
            with open(temp_file, 'rb') as html_file:
                await update.callback_query.message.reply_document(document=html_file, filename=temp_file)
        else:
            with open(temp_file, 'rb') as html_file:
                await update.message.reply_document(document=html_file, filename=temp_file)

        # X√≥a file t·∫°m
        os.remove(temp_file)
    except Exception as e:
        if update.callback_query:
            await update.callback_query.message.reply_text(f"ƒê√£ x·∫£y ra l·ªói: {e}")
        else:
            await update.message.reply_text(f"ƒê√£ x·∫£y ra l·ªói: {e}")



async def top(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """G·ª≠i danh s√°ch top 10 c·∫∑p giao d·ªãch tƒÉng, gi·∫£m m·∫°nh nh·∫•t v·ªõi n√∫t t∆∞∆°ng t√°c."""
    try:
        # L·∫•y d·ªØ li·ªáu th·ªã tr∆∞·ªùng t·ª´ KuCoin
        markets = exchange.fetch_tickers()
        data = []

        # T√≠nh to√°n ph·∫ßn trƒÉm bi·∫øn ƒë·ªông gi√° v√† kh·ªëi l∆∞·ª£ng giao d·ªãch
        for symbol, ticker in markets.items():
            change = ticker.get('percentage')
            if change is not None:
                data.append((symbol, change))


        # L·∫•y top 10 tƒÉng, gi·∫£m m·∫°nh nh·∫•t 
        top_gainers = sorted(data, key=lambda x: x[1], reverse=True)[:10]
        top_losers = sorted(data, key=lambda x: x[1])[:10]

        # T·∫°o danh s√°ch n√∫t t∆∞∆°ng t√°c cho top tƒÉng
        gainers_keyboard = [
            [InlineKeyboardButton(f"{symbol}: +{change:.2f}%", callback_data=symbol)]
            for symbol, change in top_gainers
        ]

        # T·∫°o danh s√°ch n√∫t t∆∞∆°ng t√°c cho top gi·∫£m
        losers_keyboard = [
            [InlineKeyboardButton(f"{symbol}: {change:.2f}%", callback_data=symbol)]
            for symbol, change in top_losers
        ]


        # G·ª≠i danh s√°ch top tƒÉng m·∫°nh nh·∫•t
        await update.message.reply_text(
            "Top 10 c·∫∑p giao d·ªãch tƒÉng m·∫°nh nh·∫•t trong 24 gi·ªù qua:",
            reply_markup=InlineKeyboardMarkup(gainers_keyboard)
        )

        # G·ª≠i danh s√°ch top gi·∫£m m·∫°nh nh·∫•t
        await update.message.reply_text(
            "Top 10 c·∫∑p giao d·ªãch gi·∫£m m·∫°nh nh·∫•t trong 24 gi·ªù qua:",
            reply_markup=InlineKeyboardMarkup(losers_keyboard)
        )


    except Exception as e:
        await update.message.reply_text(f"ƒê√£ x·∫£y ra l·ªói: {e}")



async def button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """X·ª≠ l√Ω n√∫t b·∫•m t·ª´ danh s√°ch /top ƒë·ªÉ hi·ªÉn th·ªã bi·ªÉu ƒë·ªì k·ªπ thu·∫≠t."""
    query = update.callback_query
    await query.answer()


    # L·∫•y m√£ giao d·ªãch t·ª´ callback_data
    symbol = query.data
    context.chat_data["symbol"] = symbol  # L∆∞u v√†o chat_data ƒë·ªÉ g·ªçi l·∫°i n·∫øu c·∫ßn
    await chart(update, context)


async def list_signals(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Hi·ªÉn th·ªã top 10 c·∫∑p giao d·ªãch c√≥ t√≠n hi·ªáu mua v√† t√≠n hi·ªáu b√°n g·∫ßn ƒë√¢y."""
    try:
        # L·∫•y danh s√°ch m√£ giao d·ªãch
        markets = exchange.load_markets()
        symbols = list(markets.keys())
        timeframe = '2h'
        limit = 200
        buy_signals = []
        sell_signals = []

        for symbol in symbols:
            try:
                # L·∫•y d·ªØ li·ªáu t·ª´ KuCoin
                ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
                df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
                df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')

                # T√≠nh to√°n c√°c ch·ªâ b√°o k·ªπ thu·∫≠t
                df['MA50'] = df['close'].rolling(window=50).mean()
                df['EMA12'] = df['close'].ewm(span=12).mean()
                df['EMA26'] = df['close'].ewm(span=26).mean()
                df['MACD'] = df['EMA12'] - df['EMA26']
                df['Signal'] = df['MACD'].ewm(span=9).mean()
                delta = df['close'].diff()
                gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
                loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
                rs = gain / loss
                df['RSI'] = 100 - (100 / (1 + rs))
                df['BB_Middle'] = df['close'].rolling(window=20).mean()
                df['BB_Upper'] = df['BB_Middle'] + 2 * df['close'].rolling(window=20).std()
                df['BB_Lower'] = df['BB_Middle'] - 2 * df['close'].rolling(window=20).std()

                # L·∫•y t√≠n hi·ªáu g·∫ßn nh·∫•t
                last_row = df.iloc[-1]
                current_time = last_row['timestamp'].strftime('%Y-%m-%d %H:%M:%S')
                current_price = last_row['close']

                # L·∫•y ƒë∆°n v·ªã gi√° t·ª´ c·∫∑p giao d·ªãch
                quote_currency = symbol.split('/')[1] if '/' in symbol else 'USD'

                # T√≠n hi·ªáu mua
                if last_row['close'] > last_row['MA50'] and last_row['MACD'] > last_row['Signal'] and last_row['RSI'] < 30:
                    buy_signals.append((symbol, current_price, current_time, quote_currency))
                elif last_row['close'] <= last_row['BB_Lower']:
                    buy_signals.append((symbol, current_price, current_time, quote_currency))

                # T√≠n hi·ªáu b√°n
                if last_row['close'] < last_row['MA50'] and last_row['MACD'] < last_row['Signal'] and last_row['RSI'] > 70:
                    sell_signals.append((symbol, current_price, current_time, quote_currency))
                elif last_row['close'] >= last_row['BB_Upper']:
                    sell_signals.append((symbol, current_price, current_time, quote_currency))

            except Exception as e:
                print(f"L·ªói khi x·ª≠ l√Ω {symbol}: {e}")
                continue

        # L·∫•y top 10 t√≠n hi·ªáu mua v√† b√°n
        top_buy_signals = sorted(buy_signals, key=lambda x: x[2], reverse=True)[:10]
        top_sell_signals = sorted(sell_signals, key=lambda x: x[2], reverse=True)[:10]

        # T·∫°o danh s√°ch n√∫t t∆∞∆°ng t√°c cho t√≠n hi·ªáu mua
        buy_keyboard = [
            [InlineKeyboardButton(f"{symbol}: Mua ({price:.8f} {unit})", callback_data=symbol)]
            for symbol, price, _, unit in top_buy_signals
        ]

        # T·∫°o danh s√°ch n√∫t t∆∞∆°ng t√°c cho t√≠n hi·ªáu b√°n
        sell_keyboard = [
            [InlineKeyboardButton(f"{symbol}: B√°n ({price:.8f} {unit})", callback_data=symbol)]
            for symbol, price, _, unit in top_sell_signals
        ]

        # G·ª≠i danh s√°ch t√≠n hi·ªáu mua
        if buy_keyboard:
            await update.message.reply_text(
                "Top 10 c·∫∑p giao d·ªãch c√≥ t√≠n hi·ªáu MUA g·∫ßn ƒë√¢y:",
                reply_markup=InlineKeyboardMarkup(buy_keyboard)
            )
        else:
            await update.message.reply_text("Hi·ªán kh√¥ng c√≥ t√≠n hi·ªáu MUA n√†o g·∫ßn ƒë√¢y.")

        # G·ª≠i danh s√°ch t√≠n hi·ªáu b√°n
        if sell_keyboard:
            await update.message.reply_text(
                "Top 10 c·∫∑p giao d·ªãch c√≥ t√≠n hi·ªáu B√ÅN g·∫ßn ƒë√¢y:",
                reply_markup=InlineKeyboardMarkup(sell_keyboard)
            )
        else:
            await update.message.reply_text("Hi·ªán kh√¥ng c√≥ t√≠n hi·ªáu B√ÅN n√†o g·∫ßn ƒë√¢y.")

    except Exception as e:
        await update.message.reply_text(f"ƒê√£ x·∫£y ra l·ªói: {e}")


async def signal(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Qu√©t t√≠n hi·ªáu trong v√≤ng 7 ng√†y, n·∫øu c√≥ B√ÅN th√¨ t√¨m gi√° mua g·∫ßn nh·∫•t (c√≥ th·ªÉ ngo√†i 7 ng√†y) ƒë·ªÉ t√≠nh l√£i/l·ªó, nh∆∞ng kh√¥ng hi·ªÉn th·ªã t√≠n hi·ªáu ngo√†i 7 ng√†y."""
    try:
        symbol = context.args[0] if context.args else None
        if not symbol:
            await update.message.reply_text("Vui l√≤ng cung c·∫•p m√£ giao d·ªãch. V√≠ d·ª•: /signal BTC/USDT")
            return

        timeframe = '2h'
        limit = 500

        # Load d·ªØ li·ªáu t·ª´ s√†n giao d·ªãch
        markets = exchange.load_markets()
        if symbol not in markets:
            await update.message.reply_text(f"M√£ giao d·ªãch kh√¥ng h·ª£p l·ªá: {symbol}. Vui l√≤ng ki·ªÉm tra l·∫°i.")
            return

        ohlcv = exchange.fetch_ohlcv(symbol, timeframe, limit=limit)
        df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

        # Chuy·ªÉn timestamp sang gi·ªù Vi·ªát Nam
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms', utc=True).dt.tz_convert('Asia/Ho_Chi_Minh')

        # T√≠nh to√°n ch·ªâ b√°o k·ªπ thu·∫≠t
        df['MA50'] = df['close'].rolling(window=50).mean()
        df['EMA12'] = df['close'].ewm(span=12, adjust=False).mean()
        df['EMA26'] = df['close'].ewm(span=26, adjust=False).mean()
        df['MACD'] = df['EMA12'] - df['EMA26']
        df['Signal'] = df['MACD'].ewm(span=9, adjust=False).mean()
        df['BB_Middle'] = df['close'].rolling(window=20).mean()
        df['BB_Upper'] = df['BB_Middle'] + 2 * df['close'].rolling(window=20).std()
        df['BB_Lower'] = df['BB_Middle'] - 2 * df['close'].rolling(window=20).std()

        # RSI Calculation
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / loss
        df['RSI'] = 100 - (100 / (1 + rs))

        # X√°c ƒë·ªãnh kho·∫£ng th·ªùi gian 7 ng√†y qua
        past_threshold = pd.Timestamp.now(tz='Asia/Ho_Chi_Minh') - pd.Timedelta(days=7)
        df_past = df[df['timestamp'] >= past_threshold]

        # Danh s√°ch t√≠n hi·ªáu (ch·ªâ trong 7 ng√†y)
        signals_list = []
        last_buy_signal = None  # D√πng ƒë·ªÉ t√¨m gi√° mua g·∫ßn nh·∫•t, c√≥ th·ªÉ v∆∞·ª£t 7 ng√†y

        for _, row in df.iterrows():  # Duy·ªát to√†n b·ªô l·ªãch s·ª≠ ƒë·ªÉ t√¨m gi√° mua g·∫ßn nh·∫•t
            # N·∫øu ph√°t hi·ªán t√≠n hi·ªáu MUA (k·ªÉ c·∫£ ngo√†i 7 ng√†y), l∆∞u l·∫°i gi√° mua g·∫ßn nh·∫•t
            if (row['close'] > row['MA50'] and row['MACD'] > row['Signal'] and row['RSI'] < 30) or (row['close'] <= row['BB_Lower']):
                last_buy_signal = {"price": row['close'], "timestamp": row['timestamp']}  # L∆∞u gi√° mua g·∫ßn nh·∫•t

            # N·∫øu t√≠n hi·ªáu n·∫±m trong 7 ng√†y g·∫ßn nh·∫•t, x·ª≠ l√Ω hi·ªÉn th·ªã
            if row['timestamp'] >= past_threshold:
                timestamp_str = row['timestamp'].strftime('%Y-%m-%d %H:%M:%S')

                # ‚úÖ N·∫øu l√† t√≠n hi·ªáu MUA -> Hi·ªÉn th·ªã & T√≠nh l√£i/l·ªó d·ª±a tr√™n gi√° hi·ªán t·∫°i
                if (row['close'] > row['MA50'] and row['MACD'] > row['Signal'] and row['RSI'] < 30) or (row['close'] <= row['BB_Lower']):
                    profit_loss = ((df.iloc[-1]['close'] - row['close']) / row['close']) * 100  # L√£i/L·ªó so v·ªõi gi√° hi·ªán t·∫°i
                    profit_icon = "üü¢" if profit_loss > 0 else "üü°" if profit_loss == 0 else "üî¥"
                    signals_list.append(f"üü¢ Mua: Gi√° {row['close']:.2f} USDT v√†o l√∫c {timestamp_str}. {profit_icon} L√£i/L·ªó: {profit_loss:.2f}%")

                # ‚úÖ N·∫øu l√† t√≠n hi·ªáu B√ÅN -> T√¨m gi√° mua g·∫ßn nh·∫•t (c√≥ th·ªÉ v∆∞·ª£t 7 ng√†y) ƒë·ªÉ t√≠nh l√£i/l·ªó, nh∆∞ng kh√¥ng hi·ªÉn th·ªã gi√° mua c≈©
                elif (row['close'] < row['MA50'] and row['MACD'] < row['Signal'] and row['RSI'] > 70) or (row['close'] >= row['BB_Upper']):
                    if last_buy_signal:  # Ch·ªâ t√≠nh l√£i/l·ªó n·∫øu c√≥ gi√° mua tr∆∞·ªõc ƒë√≥
                        profit_loss = ((row['close'] - last_buy_signal['price']) / last_buy_signal['price']) * 100
                        profit_icon = "üü¢" if profit_loss > 0 else "üü°" if profit_loss == 0 else "üî¥"
                        signals_list.append(f"üî¥ B√°n: Gi√° {row['close']:.2f} USDT v√†o l√∫c {timestamp_str}. {profit_icon} L√£i/L·ªó: {profit_loss:.2f}%")

        # üì® G·ª≠i tin nh·∫Øn v·ªÅ t√≠n hi·ªáu
        signal_message = f"üìä *T√≠n hi·ªáu giao d·ªãch cho {symbol}:*\n\n"
        signal_message += "‚ö° *T√≠n hi·ªáu hi·ªán t·∫°i:* Kh√¥ng c√≥ t√≠n hi·ªáu r√µ r√†ng.\n\n"
        signal_message += "üìÖ *T√≠n hi·ªáu trong 7 ng√†y qua:*\n" + ("\n".join(signals_list) if signals_list else "Kh√¥ng c√≥ t√≠n hi·ªáu.")

        await update.message.reply_text(signal_message, parse_mode="Markdown")

    except Exception as e:
        error_message = f"L·ªói: {e}\n{traceback.format_exc()}"
        print(error_message)
        await update.message.reply_text("‚ùå ƒê√£ x·∫£y ra l·ªói. Vui l√≤ng th·ª≠ l·∫°i sau.")


async def info(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """L·∫•y th√¥ng tin chi ti·∫øt v·ªÅ m·ªôt ƒë·ªìng coin t·ª´ CoinGecko d·ª±a tr√™n t√™n ƒë·∫ßy ƒë·ªß."""
    try:
        if not context.args:
            await update.message.reply_text("Vui l√≤ng cung c·∫•p t√™n coin. V√≠ d·ª•: /info bitcoin")
            return

        coin_name = "-".join(context.args).lower()  # X·ª≠ l√Ω t√™n c√≥ d·∫•u c√°ch (v√≠ d·ª•: "bitcoin cash" -> "bitcoin-cash")

        # G·ªçi API ƒë·ªÉ l·∫•y th√¥ng tin chi ti·∫øt c·ªßa coin
        url = f"https://api.coingecko.com/api/v3/coins/{coin_name}"
        response = requests.get(url)
        if response.status_code != 200:
            await update.message.reply_text(f"Kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ ƒë·ªìng coin: {coin_name}. Vui l√≤ng ki·ªÉm tra l·∫°i.")
            return

        data = response.json()

        # Ki·ªÉm tra v√† x·ª≠ l√Ω NoneType tr∆∞·ªõc khi format
        def safe_format(value, format_str="{:.2f}"):
            return format_str.format(value) if value is not None else "N/A"

        price_usd = safe_format(data['market_data']['current_price'].get('usd'))
        high_24h = safe_format(data['market_data']['high_24h'].get('usd'))
        all_time_high = safe_format(data['market_data']['ath'].get('usd'))  # Gi√° cao nh·∫•t t·ª´ khi ni√™m y·∫øt
        change_1h = safe_format(data['market_data']['price_change_percentage_1h_in_currency'].get('usd'))
        change_24h = safe_format(data['market_data']['price_change_percentage_24h_in_currency'].get('usd'))
        change_7d = safe_format(data['market_data']['price_change_percentage_7d_in_currency'].get('usd'))
        market_cap = safe_format(data['market_data']['market_cap'].get('usd'), "{:,.2f}")
        volume_24h = safe_format(data['market_data']['total_volume'].get('usd'), "{:,.2f}")
        circulating_supply = safe_format(data['market_data']['circulating_supply'], "{:,.0f}")
        max_supply = safe_format(data['market_data']['max_supply'], "{:,.0f}")
        fully_diluted_valuation = safe_format(data['market_data']['fully_diluted_valuation'].get('usd'), "{:,.2f}")  # Th√™m FDV

        message = (
            f"üìä *Th√¥ng tin v·ªÅ {data['name']} ({data['symbol'].upper()})*:\n"
            f"üí∞ Gi√° hi·ªán t·∫°i: *${price_usd}*\n"
            f"üî∫ Gi√° cao nh·∫•t 24h: *${high_24h}*\n"
            f"üöÄ Gi√° cao nh·∫•t m·ªçi th·ªùi ƒë·∫°i: *${all_time_high}*\n"
            f"üìà Thay ƒë·ªïi gi√° (1 gi·ªù): *{change_1h}%*\n"
            f"üìà Thay ƒë·ªïi gi√° (24 gi·ªù): *{change_24h}%*\n"
            f"üìà Thay ƒë·ªïi gi√° (7 ng√†y): *{change_7d}%*\n"
            f"üè¶ V·ªën h√≥a th·ªã tr∆∞·ªùng: *${market_cap}*\n"
            f"üíé V·ªën h√≥a pha lo√£ng ho√†n to√†n (FDV): *${fully_diluted_valuation}*\n"  # Hi·ªÉn th·ªã FDV
            f"üìä Kh·ªëi l∆∞·ª£ng giao d·ªãch 24 gi·ªù: *${volume_24h}*\n"
            f"üîÑ L∆∞·ª£ng ti·ªÅn ƒëang l∆∞u th√¥ng: *{circulating_supply} {data['symbol'].upper()}*\n"
            f"üõë Ngu·ªìn cung t·ªëi ƒëa: *{max_supply} {data['symbol'].upper()}*\n"
        )

        await update.message.reply_text(message, parse_mode="Markdown")

    except Exception as e:
        await update.message.reply_text(f"ƒê√£ x·∫£y ra l·ªói: {e}")


TIMEFRAME_MAPPING = {
    "1h": "price_change_percentage_1h_in_currency",
    "1d": "price_change_percentage_24h_in_currency",
    "1w": "price_change_percentage_7d_in_currency"
}

async def send_heatmap(chat, timeframe: str):
    """T·∫°o v√† g·ª≠i heatmap c√≥ m√†u gi·ªëng h√¨nh m·∫´u"""
    try:
        print(f"üìå ƒêang t·∫°o heatmap cho: {timeframe}")

        url = "https://api.coingecko.com/api/v3/coins/markets"
        params = {
            "vs_currency": "usd",
            "order": "market_cap_desc",
            "per_page": 100,
            "page": 1,
            "sparkline": False,
            "price_change_percentage": "1h,24h,7d"
        }
        response = requests.get(url, params=params)
        data = response.json()

        if response.status_code != 200 or not data:
            await chat.send_message("‚ùå Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu t·ª´ CoinGecko. Vui l√≤ng th·ª≠ l·∫°i sau!")
            return

        price_change_column = TIMEFRAME_MAPPING.get(timeframe)
        if price_change_column is None:
            await chat.send_message("‚ö†Ô∏è Sai khung th·ªùi gian! Vui l√≤ng ch·ªçn 1h, 1d ho·∫∑c 1w.")
            return

        df = pd.DataFrame(data)
        if price_change_column not in df.columns:
            await chat.send_message(f"‚ùå API kh√¥ng tr·∫£ v·ªÅ d·ªØ li·ªáu cho `{timeframe}`. Vui l√≤ng th·ª≠ l·∫°i sau!")
            return

        df["price_change"] = df[price_change_column]
        df = df.dropna(subset=["price_change"])

        # üîπ S·∫Øp x·∫øp theo v·ªën h√≥a th·ªã tr∆∞·ªùng l·ªõn nh·∫•t ‚Üí nh·ªè nh·∫•t
        df = df.sort_values("market_cap", ascending=False)

        # üîπ D√πng sqrt(v·ªën h√≥a) ƒë·ªÉ gi·∫£m ch√™nh l·ªách k√≠ch th∆∞·ªõc
        df["size"] = np.sqrt(df["market_cap"])

        # üîπ D√πng abs(price_change) ƒë·ªÉ l√†m gi√° tr·ªã m√†u (c√†ng l·ªõn m√†u c√†ng ƒë·∫≠m)
        df["color_intensity"] = np.abs(df["price_change"])

        # üîπ Ch·ªânh h·ªá m√†u gi·ªëng nh∆∞ heatmap m·∫´u
        colorscale = [
            [0, "rgb(153, 0, 0)"],  # ƒê·ªè ƒë·∫≠m (gi·∫£m r·∫•t m·∫°nh)
            [0.3, "rgb(204, 0, 0)"],  # ƒê·ªè trung b√¨nh (gi·∫£m)
            [0.5, "rgb(255, 102, 102)"],  # ƒê·ªè nh·∫°t (gi·∫£m nh·∫π)
            [0.5, "rgb(102, 255, 102)"],  # Xanh nh·∫°t (tƒÉng nh·∫π)
            [0.7, "rgb(0, 204, 0)"],  # Xanh trung b√¨nh (tƒÉng)
            [1, "rgb(0, 102, 0)"]   # Xanh ƒë·∫≠m (tƒÉng r·∫•t m·∫°nh)
        ]

        # üîπ CƒÉn ch·ªânh vƒÉn b·∫£n ƒë·ªÅu trong t·ª´ng √¥
        df["text"] = df.apply(lambda row: f"<b>{row['symbol'].upper()}</b><br>${row['current_price']:,.2f}<br>{row['price_change']:.2f}%", axis=1)

        fig = go.Figure(data=go.Treemap(
            labels=df["symbol"].str.upper(),
            parents=[""] * len(df),
            values=df["size"],
            text=df["text"],
            textinfo="text",
            texttemplate="%{text}",
            marker=dict(
                colors=df["price_change"],
                colorscale=colorscale,
                cmid=0,
                showscale=True
            )
        ))

        fig.update_layout(
            title=f"üìä Heatmap top 100 coins ({timeframe.upper()})",
            template="plotly_dark"
        )

        html_path = f"heatmap_{timeframe}.html"
        fig.write_html(html_path)

        if not os.path.exists(html_path):
            await chat.send_message(f"‚ùå L·ªói khi t·∫°o file heatmap_{timeframe}.html. Vui l√≤ng th·ª≠ l·∫°i!")
            return
        else:
            print(f"‚úÖ File {html_path} ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng!")

        await chat.send_document(document=open(html_path, "rb"), filename=html_path)

        # X√≥a file sau khi g·ª≠i xong (ch·ªù 10 gi√¢y)
        await asyncio.sleep(10)
        os.remove(html_path)
        print(f"üóëÔ∏è File {html_path} ƒë√£ ƒë∆∞·ª£c x√≥a.")

    except Exception as e:
        await chat.send_message(f"‚ùå ƒê√£ x·∫£y ra l·ªói: {e}")

async def heatmap(update, context):
    """L·ªánh /heatmap t·ª± ƒë·ªông g·ª≠i 3 heatmap (1h, 1d, 1w) v·ªõi m√†u s·∫Øc theo m·∫´u"""
    await update.message.reply_text("üìä ƒêang t·∫°o heatmap 1h, 1d, 1w. Vui l√≤ng ch·ªù...")
    
    await send_heatmap(update.effective_chat, "1h")
    await send_heatmap(update.effective_chat, "1d")
    await send_heatmap(update.effective_chat, "1w")


async def desc(update, context):
    """L·∫•y th√¥ng tin chi ti·∫øt v·ªÅ ƒë·ªìng coin t·ª´ CoinGecko (bao g·ªìm website v√† community)."""
    try:
        if not context.args:
            await update.message.reply_text("Vui l√≤ng cung c·∫•p m√£ coin. V√≠ d·ª•: /desc BTC")
            return

        coin_symbol = context.args[0].lower()

        # üîπ G·ªçi API CoinGecko ƒë·ªÉ l·∫•y d·ªØ li·ªáu
        url_coingecko = f"https://api.coingecko.com/api/v3/coins/{coin_symbol}?localization=false"
        response_coingecko = requests.get(url_coingecko)

        if response_coingecko.status_code != 200:
            await update.message.reply_text(f"Kh√¥ng t√¨m th·∫•y th√¥ng tin cho {coin_symbol}. Vui l√≤ng ki·ªÉm tra l·∫°i.")
            return

        data_coingecko = response_coingecko.json()
        coin_name = data_coingecko.get("name", "Kh√¥ng c√≥ th√¥ng tin")
        symbol = data_coingecko.get("symbol", "N/A").upper()
        categories = ", ".join(data_coingecko.get("categories", ["Kh√¥ng c√≥ th√¥ng tin"]))

        # L·∫•y m√¥ t·∫£ ti·∫øng Vi·ªát n·∫øu c√≥, n·∫øu kh√¥ng th√¨ l·∫•y m√¥ t·∫£ ti·∫øng Anh
        description_vi = data_coingecko["description"].get("vi")
        description_en = data_coingecko["description"].get("en")
        description = description_vi if description_vi else description_en if description_en else "Kh√¥ng c√≥ m√¥ t·∫£."

        # üîπ L·∫•y th√¥ng tin website
        website = data_coingecko.get("links", {}).get("homepage", ["Kh√¥ng c√≥ th√¥ng tin"])[0]

        # üîπ L·∫•y th√¥ng tin c·ªông ƒë·ªìng (hi·ªÉn th·ªã link)
        community_links = []
        links = data_coingecko.get("links", {})

        if links.get("twitter_screen_name"):
            community_links.append(f"‚ùå [X](https://twitter.com/{links['twitter_screen_name']})")
        if links.get("facebook_username"):
            community_links.append(f"‚íª [Facebook](https://www.facebook.com/{links['facebook_username']})")
        if links.get("telegram_channel_identifier"):
            community_links.append(f"üì¢ [Telegram](https://t.me/{links['telegram_channel_identifier']})")
        if links.get("subreddit_url"):
            community_links.append(f"‚ìá [Reddit]({links['subreddit_url']})")
        if links.get("discord_url"):
            community_links.append(f"üéÆ [Discord]({links['discord_url']})")

        community = "\n".join(community_links) if community_links else "Kh√¥ng c√≥ th√¥ng tin"

        # üîπ ƒê·ªãnh d·∫°ng l·∫°i th√¥ng tin
        message = (
            f"*{coin_name} - ${symbol}*\n\n"
            f"üìå *Danh m·ª•c*: {categories}\n\n"
            f"üìñ *M√¥ t·∫£*: {description}\n\n"
            f"üåê *Website*: {website}\n"
            f"üèõÔ∏è *C·ªông ƒë·ªìng*:\n{community}"
        )

        await update.message.reply_text(message, parse_mode="Markdown", disable_web_page_preview=True)

    except Exception as e:
        await update.message.reply_text(f"ƒê√£ x·∫£y ra l·ªói: {e}")

async def sentiment(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """L·∫•y ch·ªâ s·ªë Fear & Greed t·ª´ alternative.me, hi·ªÉn th·ªã text v√† g·ª≠i ·∫£nh m·ªõi nh·∫•t."""
    try:
        # G·ªçi API alternative.me
        url = "https://api.alternative.me/fng/"
        response = requests.get(url)
        data = response.json()

        if "data" not in data or not data["data"]:
            await update.message.reply_text("‚ùå Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu ch·ªâ s·ªë Fear & Greed. Vui l√≤ng th·ª≠ l·∫°i sau!")
            return

        # L·∫•y th√¥ng tin ch·ªâ s·ªë
        fng_data = data["data"][0]
        value = int(fng_data["value"])
        status = fng_data["value_classification"]
        last_updated = datetime.utcfromtimestamp(int(fng_data["timestamp"])).strftime('%Y-%m-%d')

        # X√°c ƒë·ªãnh m√†u v√† icon ph√π h·ª£p
        if value < 25:
            color = "üî¥ (Extreme Fear)"
        elif value < 50:
            color = "üü† (Fear)"
        elif value < 75:
            color = "üü¢ (Greed)"
        else:
            color = "üü¢üü¢ (Extreme Greed)"

        # URL ·∫£nh (th√™m timestamp ƒë·ªÉ tr√°nh cache)
        timestamp = int(time.time())  # Th·ªùi gian hi·ªán t·∫°i theo gi√¢y
        image_url = f"https://alternative.me/crypto/fear-and-greed-index.png?{timestamp}"

        # G·ª≠i tin nh·∫Øn vƒÉn b·∫£n tr∆∞·ªõc
        message = (
            f"üìä *Crypto Fear & Greed Index*\n"
            f"üìÖ *Ng√†y c·∫≠p nh·∫≠t:* {last_updated}\n"
            f"üìà *Ch·ªâ s·ªë hi·ªán t·∫°i:* {value}/100\n"
            f"‚öñÔ∏è *T√¢m l√Ω th·ªã tr∆∞·ªùng:* {status} {color}"
        )
        await update.message.reply_text(message, parse_mode="Markdown")

        # G·ª≠i ·∫£nh sau (lu√¥n l·∫•y ·∫£nh m·ªõi nh·∫•t)
        await update.message.reply_photo(photo=image_url, caption="üñº Fear & Greed Index Chart (Updated)")

    except Exception as e:
        await update.message.reply_text(f"‚ùå L·ªói khi l·∫•y d·ªØ li·ªáu: {e}")

async def trending(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """L·∫•y danh s√°ch c√°c ƒë·ªìng coin ƒëang trending tr√™n CoinGecko v√† hi·ªÉn th·ªã x·∫øp h·∫°ng v·ªën h√≥a."""
    try:
        # G·ªçi API CoinGecko
        url = "https://api.coingecko.com/api/v3/search/trending"
        response = requests.get(url)
        data = response.json()

        if "coins" not in data or not data["coins"]:
            await update.message.reply_text("‚ùå Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu trending. Vui l√≤ng th·ª≠ l·∫°i sau!")
            return

        # L·∫•y danh s√°ch top trending coins
        trending_coins = data["coins"][:15]  # L·∫•y top 15 coin trending

        # T·∫°o danh s√°ch hi·ªÉn th·ªã
        trending_list = []
        for index, coin in enumerate(trending_coins, start=1):
            name = coin["item"]["name"]
            symbol = coin["item"]["symbol"].upper()
            market_cap_rank = coin["item"].get("market_cap_rank", "N/A")  # L·∫•y x·∫øp h·∫°ng v·ªën h√≥a
            link = f"[{name} ($ {symbol})](https://www.coingecko.com/en/coins/{coin['item']['id']})"
            trending_list.append(f"{index}.) {link} | {market_cap_rank}")

        # T·∫°o n·ªôi dung tin nh·∫Øn
        message = "üî• *Search Trends - Coingecko* üî•\n\n" + "\n".join(trending_list)

        # G·ª≠i tin nh·∫Øn v·ªõi Markdown
        await update.message.reply_text(message, parse_mode="Markdown", disable_web_page_preview=True)

    except Exception as e:
        await update.message.reply_text(f"‚ùå L·ªói khi l·∫•y d·ªØ li·ªáu: {e}")



async def set_webhook(application: Application):
    """Thi·∫øt l·∫≠p Webhook."""
    await application.bot.set_webhook(WEBHOOK_URL)

def main():
    # L·∫•y c·ªïng t·ª´ bi·∫øn m√¥i tr∆∞·ªùng ho·∫∑c s·ª≠ d·ª•ng c·ªïng m·∫∑c ƒë·ªãnh
    port = int(os.getenv("PORT", 8080))
    print(f"ƒêang s·ª≠ d·ª•ng c·ªïng: {port}")  # Log ki·ªÉm tra c·ªïng

    # Kh·ªüi t·∫°o ·ª©ng d·ª•ng Telegram bot
    application = Application.builder().token(TOKEN).build()

    # ƒêƒÉng k√Ω c√°c handler
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("chart", chart))
    application.add_handler(CommandHandler("signal", signal))
    application.add_handler(CommandHandler("top", top))  # Th√™m handler cho /top
    application.add_handler(CommandHandler("list", list_signals))
    application.add_handler(CommandHandler("smarttrade", current_price))  # Th√™m handler cho /cap
    application.add_handler(CommandHandler("info", info))
    application.add_handler(CallbackQueryHandler(button))  # Th√™m handler cho n√∫t b·∫•m t·ª´ /top
    application.add_handler(CommandHandler("heatmap", heatmap))
    application.add_handler(CommandHandler("desc", desc))
    application.add_handler(CommandHandler("sentiment", sentiment))
    application.add_handler(CommandHandler("trending", trending))


    # Ch·∫°y webhook
    application.run_webhook(
        listen="0.0.0.0",
        port=port,
        webhook_url=WEBHOOK_URL
    )

if __name__ == "__main__":
    main()





